# Python Turns 35 Today: The Language That Rewrote the Rules of Programming

## From a Christmas hobby project to the world's most popular language, how Python shaped modern software and why it still matters

![Python Turns 35](../images/featured-python-35.png)

**Author**: [Wallace Espindola](https://github.com/wallaceespindola/)
**Published**: February 20, 2026
**Reading Time**: 15 minutes

---

## Table of Contents

- [Introduction: Why 35 Matters](#introduction-why-35-matters)
- [Phase 1 (1991--2000): The Academic and Scripting Years](#phase-1-19912000-the-academic-and-scripting-years)
- [Phase 2 (2000--2010): Web Expansion and the Rise of Frameworks](#phase-2-20002010-web-expansion-and-the-rise-of-frameworks)
- [Phase 3 (2010--2020): The Data Science Revolution](#phase-3-20102020-the-data-science-revolution)
- [Phase 4 (2020--Present): Platform Language and Cloud Era](#phase-4-2020present-platform-language-and-cloud-era)
- [Python's Evolution Timeline](#pythons-evolution-timeline)
- [Why Python Survived 35 Years](#why-python-survived-35-years)
- [Strong Points Today](#strong-points-today)
- [Opportunities to Improve](#opportunities-to-improve)
- [Java at 30: A Philosophical Comparison](#java-at-30-a-philosophical-comparison)
- [The Future Outlook](#the-future-outlook)
- [Conclusion: Key Takeaways](#conclusion-key-takeaways)
- [About the Author](#about-the-author)

---

## Introduction: Why 35 Matters

Today, February 20, 2026, marks exactly 35 years since Guido van Rossum released the first version of Python to the world. That's 35 years of a language that started as a Christmas holiday side project and became the most widely used programming language on the planet.

Think about that for a moment. Most software technologies don't survive five years. Frameworks come and go. Languages rise and fade. But Python didn't just survive, it thrived. It evolved. It conquered entirely new domains that didn't even exist when it was born.

When Guido sat down during the holiday break of 1989 to start writing an interpreter for a new scripting language, he wasn't trying to build the next big thing. He wanted a better tool. Something cleaner than C, more capable than shell scripting and more approachable than the languages available at the time. He named it after Monty Python's Flying Circus, because he wanted programming to be fun.

That decision to prioritize human readability over machine efficiency? It turned out to be one of the most consequential design choices in the history of computing.

So let's walk through how we got here. Four distinct phases, 35 years of evolution and a language that keeps reinventing itself without ever losing what made it special.

---

## Phase 1 (1991--2000): The Academic and Scripting Years

Python 0.9.0 arrived on February 20, 1991, posted to the alt.sources newsgroup. If you weren't around for Usenet, just imagine a giant public bulletin board where programmers shared code. That's where Python first saw the light of day.

From the very beginning, Python was different. While other languages of that era focused on giving developers maximum control over hardware, Python focused on giving developers maximum clarity in their thinking.

**What made it stand out:**

- **Indentation-based syntax.** This was controversial then and it's still debated now. Instead of using curly braces to define code blocks, Python uses whitespace. Love it or hate it, it forces code to be visually clean. You can't write messy Python, the language won't let you.

- **Dynamic typing.** You don't need to declare variable types. Just assign a value and Python figures out the rest. This felt like magic to developers coming from C or Pascal.

- **A cleaner alternative to C.** You could accomplish in ten lines of Python what took fifty lines of C. And the Python version was actually readable six months later.

- **Batteries included.** Python shipped with a standard library that handled common tasks like file I/O, string manipulation, regular expressions and networking. You didn't need to hunt for third-party libraries just to read a CSV file.

During this decade, Python found its first natural home in academia and system administration. University professors loved it as a teaching language because students could focus on algorithms and logic instead of wrestling with syntax. System administrators loved it because it was a much better glue language than Bash for automating tasks across Linux and Unix systems.

Python 1.0 landed in January 1994, bringing lambda, map, filter and reduce, functional programming tools that gave the language surprising depth. By the time Python 2.0 arrived in October 2000, the language had list comprehensions, garbage collection and a growing community that genuinely enjoyed writing code in it.

This first decade wasn't about world domination. It was about building a solid foundation and a philosophy, the Zen of Python, that would guide every decision that came after.

---

## Phase 2 (2000--2010): Web Expansion and the Rise of Frameworks

The 2000s changed everything for Python. The internet was exploding and everyone needed to build web applications fast. Python was perfectly positioned.

**Django arrived in 2005** and it changed the conversation entirely. Built by a team at the Lawrence Journal-World newspaper (yes, a newspaper), Django was a full-stack web framework that followed the "batteries included" philosophy Python was already known for. It came with an ORM, an admin panel, authentication, URL routing and template rendering all built in. You could go from zero to a functional web application in an afternoon.

Django's tagline, "The web framework for perfectionists with deadlines", captured exactly why Python was winning developer hearts. You could build things quickly without sacrificing code quality.

**Flask appeared in 2010**, offering the opposite approach. Where Django gave you everything, Flask gave you almost nothing, by design. It was a micro-framework that let you pick and choose your own components. Need a database? Pick your own ORM. Need templates? Choose your engine. This flexibility attracted developers who wanted more control over their stack.

Between Django and Flask, Python had the web covered from both directions.

But web frameworks were only part of the story. During this decade:

- **Linux distributions adopted Python as a system language.** If you ran Ubuntu, CentOS or Fedora, Python was already installed. System tools, package managers and configuration scripts were increasingly written in Python.

- **Startups embraced Python for rapid prototyping.** When you're racing to build an MVP, development speed matters more than raw execution speed. Python let small teams build and ship products faster than the competition.

- **Google, YouTube and Dropbox** were using Python extensively in production, proving it could handle serious scale when architected properly.

- **The community grew dramatically.** PyPI (the Python Package Index) became the go-to repository for third-party packages, and the ecosystem started showing the network effects that would later make Python nearly unstoppable.

This was the decade where Python proved it wasn't just an academic toy or a scripting language. It was a legitimate tool for building real products that served millions of users.

---

## Phase 3 (2010--2020): The Data Science Revolution

If the 2000s proved Python could build web applications, the 2010s proved it could do something far more transformative: make data science and machine learning accessible to everyone.

This is the decade that turned Python from a popular language into THE language for an entire generation of data professionals and researchers.

**The scientific Python ecosystem matured:**

- **NumPy** provided fast numerical computing with arrays and matrices, serving as the foundation that everything else was built on.
- **Pandas** gave data analysts a way to work with tabular data that felt intuitive and powerful. If you've ever loaded a CSV file with `pd.read_csv()`, you know the feeling.
- **SciPy** added scientific computing tools, optimization, signal processing, statistics and more.
- **Matplotlib** handled visualization, letting researchers create publication-quality plots with a few lines of code.
- **Jupyter Notebooks** changed how people did computational work entirely. The idea of mixing code, output and narrative text in a single document was revolutionary. It made data analysis reproducible and shareable in a way that had never been possible before.

Then machine learning and deep learning arrived and Python became the undisputed champion.

**TensorFlow (2015)** from Google and **PyTorch (2016)** from Facebook gave researchers and engineers the tools to build neural networks with Python as the primary interface. The choice of Python wasn't accidental, Google and Facebook both knew that if they wanted adoption, they needed to meet developers and researchers where they already were. And in data science, that meant Python.

**Scikit-learn** made traditional machine learning approachable. You could train a classification model with three lines of code. Not three hundred. Three.

What's remarkable about this era is how completely Python dominated. R, Julia, MATLAB, they all had their strengths, but none could match Python's combination of general-purpose programming capability and specialized data science tools. A data scientist could clean data with Pandas, build a model with scikit-learn, deploy it with Flask and automate the pipeline with standard Python, all in one language.

Python also benefited from a crucial demographic shift. A new generation of professionals was entering the workforce, data analysts, data scientists, machine learning engineers and quantitative researchers, and they were learning Python as their first (and often only) programming language. They didn't come from computer science backgrounds. They came from statistics, physics, biology, economics and business. Python's gentle learning curve and readable syntax made it the perfect bridge between domain expertise and programming capability.

By the end of this decade, knowing Python wasn't just a skill on a resume. It was practically a requirement for anyone working with data.

---

## Phase 4 (2020--Present): Platform Language and Cloud Era

We're living in Python's fourth phase right now and it might be the most interesting one yet. Python has evolved from a language you use to build things into a language that orchestrates everything.

**FastAPI changed the backend conversation.** Released in 2018 but reaching widespread adoption in the early 2020s, FastAPI brought async support, automatic API documentation and type hints to Python web development. It was faster than Django and Flask for building APIs, and its developer experience was outstanding. FastAPI showed that Python could be both developer-friendly AND performant.

**Cloud and DevOps embraced Python fully:**

- **AWS, Google Cloud and Azure** all use Python as a primary SDK language. If you're writing Lambda functions, Cloud Functions or automation scripts, you're probably writing Python.
- **Terraform, Ansible and Pulumi** either use Python directly or have Python as a first-class integration language.
- **Infrastructure as Code** became a Python-heavy discipline. Tools like AWS CDK let you define cloud infrastructure in Python, blurring the line between application code and infrastructure.

**AI orchestration became Python's new frontier.** With the explosion of large language models and generative AI, Python became the glue language for AI applications. Frameworks like LangChain, LlamaIndex and the various model provider SDKs are all Python-first. When developers build AI-powered applications today, they reach for Python instinctively.

**Education solidified Python's dominance.** Python is now the most commonly taught first programming language at universities worldwide. It's also the language of choice for coding bootcamps, online courses and self-taught developers. This creates a self-reinforcing cycle: more people learn Python, more libraries get built in Python, more jobs require Python and more people learn Python.

**The typing revolution matured.** Python's optional type hints, introduced in Python 3.5, have become increasingly sophisticated. Tools like mypy, Pyright and Pydantic brought type safety to a dynamically typed language without losing the flexibility that made Python appealing in the first place. You can write Python with full type annotations that rival statically typed languages for safety, or you can skip types entirely for quick scripts. Your choice.

In this current phase, Python isn't competing with other languages for specific use cases anymore. It's the default starting point. When someone has a new problem to solve, they ask "can I do this in Python?" and the answer is almost always yes.

---

## Python's Evolution Timeline

Here's a visual overview of Python's four phases and key milestones across 35 years:

![Python Evolution Timeline](../images/python-phases-timeline.png)

```mermaid
timeline
    title Python's 35-Year Evolution (1991-2026)

    section Phase 1: Academic & Scripting (1991-2000)
        1991 : Python 0.9.0 released on alt.sources
             : Indentation-based syntax introduced
        1994 : Python 1.0, lambda, map, filter, reduce
        1999 : Python 1.5.2, stable and widely adopted in academia
        2000 : Python 2.0, list comprehensions, garbage collection

    section Phase 2: Web Expansion (2000-2010)
        2003 : Python 2.3, sets, enumerate, logging
        2005 : Django released, full-stack web framework
        2008 : Python 3.0, the great backward-incompatible leap
        2010 : Flask released, micro-framework philosophy
             : pip becomes the standard package installer

    section Phase 3: Data Science Revolution (2010-2020)
        2012 : Pandas 0.8+ gains mainstream adoption
        2014 : Jupyter Notebook project launches
        2015 : TensorFlow released by Google
        2016 : PyTorch released by Facebook
        2017 : Python becomes #1 on IEEE Spectrum
        2019 : Python 3.8, walrus operator, positional-only params

    section Phase 4: Platform & Cloud Era (2020-Present)
        2020 : Python 3.9, dictionary merge operators
             : FastAPI reaches mainstream adoption
        2022 : Python 3.11, major performance improvements
        2023 : AI/LLM orchestration frameworks explode
        2024 : Python 3.13, experimental free-threaded mode
        2026 : Python turns 35, most popular language worldwide
```

---

## Why Python Survived 35 Years

Most programming languages don't make it to their 10th birthday as relevant tools. So how did Python not only survive 35 years but actually grow stronger with each decade? Five core reasons.

### 1. Human-Centered Design from Day One

Guido van Rossum made a deliberate choice to optimize for the developer's experience rather than the computer's performance. This philosophy is captured in the Zen of Python: "Readability counts," "Simple is better than complex," "There should be one, and preferably only one, obvious way to do it."

This wasn't just philosophy. It was a practical design constraint that shaped every feature, every syntax decision and every library in the ecosystem. The result is a language where code reads almost like English and where a beginner can understand what a piece of code does just by looking at it.

### 2. Batteries Included

Python's standard library is enormous. Want to work with JSON? It's built in. Regular expressions? Built in. HTTP requests? Built in. SQLite database? Built in. This means you can accomplish a surprising amount without installing a single third-party package.

For beginners, this removes a massive barrier. You don't need to understand package managers, dependency resolution or virtual environments just to write your first useful program.

### 3. Ecosystem Network Effects

Here's the thing about ecosystems: once they reach critical mass, they become nearly impossible to displace. Python crossed that threshold years ago. There are hundreds of thousands of packages on PyPI covering every imaginable use case. When a new technology appears, whether it's blockchain, quantum computing, AR/VR or generative AI, Python gets a library for it almost immediately.

This creates a flywheel: more users attract more library authors, who attract more users, who attract more companies, who fund more development. Breaking that cycle would require an alternative language to be not just better, but dramatically better across every dimension simultaneously.

### 4. Low Barrier to Entry

Python is one of the easiest languages to start learning. There's no compilation step, no type declarations required, no boilerplate and the syntax is clean enough that a non-programmer can usually guess what a snippet does. This accessibility has been Python's superpower for attracting talent from outside traditional computer science.

Biologists, economists, journalists, artists and educators have all come to Python because it meets them where they are instead of demanding they think like computer scientists first.

### 5. Adaptability Without Identity Loss

This is perhaps the most impressive quality. Python has reinvented itself for web development, system administration, data science, machine learning, cloud automation and AI orchestration, without ever losing its core identity. It's still readable. It's still approachable. It's still fun to write.

Many languages that try to be everything to everyone end up being nothing to anyone. Python avoided that trap by keeping its core simple while letting the ecosystem handle specialization.

---

## Strong Points Today

Let's be specific about where Python excels in 2026.

**Developer Productivity.** Python developers consistently ship features faster than equivalent teams using more verbose languages. The gap between having an idea and having a working prototype is shorter in Python than in almost any alternative. When time-to-market matters, Python wins.

**AI and Machine Learning Dominance.** This isn't even close. Python owns the AI space. Every major framework, TensorFlow, PyTorch, JAX, Hugging Face Transformers, LangChain, is Python-first. If you work in AI, you work in Python. Period.

**Massive Ecosystem.** With over 500,000 packages on PyPI, there's a library for practically everything. Web scraping, image processing, natural language processing, financial analysis, game development, robotics, name a domain and Python has tools for it.

**Cross-Domain Versatility.** Very few languages let a single developer build a web API, train a machine learning model, automate cloud infrastructure and create data visualizations. Python does all of that and more. This makes Python developers incredibly versatile.

**Prototyping Speed.** When you need to validate an idea quickly, whether it's a proof of concept for a client, a quick data analysis or a one-off automation script, Python gets you from zero to working code faster than anything else.

**The Ideal Orchestration Language.** In modern architectures, you need a language that can talk to databases, call APIs, trigger cloud functions, process data and coordinate between services. Python's readability and rich library support make it the natural choice for orchestration and glue code. It connects the pieces of your system together in a way that's maintainable and understandable.

---

## Opportunities to Improve

No honest assessment of a technology should skip its weaknesses. Python has real ones and the community is actively working on them.

### Performance: The Elephant in the Room

Python is slow compared to compiled languages. Not a little slow, often 10 to 100 times slower for CPU-intensive tasks. And memory consumption is high because everything in Python is an object, which means significant overhead for simple data types.

The good news: the core team is working on this aggressively. Python 3.11 brought measurable speed improvements. Python 3.13 introduced an experimental free-threaded mode. Projects like Cython, Mojo and PyPy offer faster alternatives while keeping Python-like syntax. For most applications, the bottleneck isn't Python's speed anyway, it's I/O, network calls or database queries. But for compute-heavy workloads, this remains a real limitation.

### Packaging Complexity

Ask five Python developers how to manage dependencies and you'll get six different answers. pip, Poetry, Pipenv, conda, uv, PDM, the ecosystem has too many competing tools and none of them has won definitively. Virtual environments are a source of confusion for beginners. Dependency resolution can be slow and frustrating. The new tool uv (from the Astral team) is making significant progress here, but the fragmentation itself is a problem.

Compare this to Rust's Cargo or Go's built-in module system, where there's exactly one way to manage dependencies. Python's packaging story is improving, but it's still one of the language's weakest points.

### Concurrency Limitations

The Global Interpreter Lock (GIL) has been Python's most famous architectural constraint for decades. It prevents true multi-threaded parallelism, which means CPU-bound tasks can't easily take advantage of modern multi-core processors.

Python 3.13's experimental free-threaded mode (PEP 703) is the most significant step toward resolving this. If it succeeds, it could eliminate one of Python's longest-standing criticisms. But it's experimental, and the ecosystem needs time to adapt. In the meantime, developers work around the GIL using multiprocessing, asyncio or external tools, which adds complexity.

### Large Enterprise Governance

Dynamic typing is wonderful for prototyping and small teams. But in large codebases maintained by hundreds of developers? It can become a liability. Without type annotations, refactoring is risky. Bugs that a compiler would catch in Java or TypeScript slip through to runtime in Python.

Type hints and tools like mypy help significantly, but they're optional. In a large organization, "optional" often means "inconsistently applied." This is why many enterprises use Python for data science and automation but choose statically typed languages for core business logic and transaction processing.

---

## Java at 30: A Philosophical Comparison

Java turned 30 in 2025 and it's still one of the most widely used languages in the world. Comparing Python at 35 with Java at 30 isn't about declaring a winner. It's about understanding two fundamentally different philosophies that have both proven remarkably successful.

![Python vs Java Comparison](../images/python-vs-java-comparison.png)

### Java's Enduring Strengths

**JVM portability.** "Write once, run anywhere" was Java's original promise and the JVM delivered on it. Java applications run on any platform with a JVM, which is essentially every platform that matters. The JVM itself has become a platform, hosting languages like Kotlin, Scala and Clojure.

**Static typing and compile-time safety.** Java catches a whole class of errors before your code ever runs. In large enterprise systems where a runtime error can cost millions, this matters enormously.

**Mature concurrency.** Java's threading model, enhanced by the virtual threads in Project Loom (Java 21+), is far more sophisticated than Python's. For high-throughput concurrent workloads, Java has a significant advantage.

**Backward compatibility.** Java takes backward compatibility seriously. Code written 20 years ago still compiles and runs. For enterprises that maintain long-lived systems, this predictability is invaluable.

**Corporate ecosystem.** Spring Boot, Jakarta EE, Hibernate, Maven, Gradle, Java's enterprise tooling is deep, mature and battle-tested at scale. When you're building a banking system that processes millions of transactions daily, you want that maturity.

### The Philosophical Comparison

| Dimension | Python | Java |
|-----------|--------|------|
| **Optimization target** | Developer happiness and productivity | Application reliability and performance |
| **Typing philosophy** | Dynamic by default, optional static hints | Static and enforced at compile time |
| **Performance profile** | Slower execution, faster development | Faster execution, more development overhead |
| **Enterprise safety** | Relies on testing and discipline | Enforced by compiler and type system |
| **AI and data science** | Dominant, first-class ecosystem | Secondary, relies on Python interop |
| **Tooling maturity** | Fragmented but improving (uv, Ruff) | Unified and mature (Maven/Gradle, IntelliJ) |
| **Concurrency model** | GIL-limited, async-first workarounds | Virtual threads, mature multi-threading |
| **Learning curve** | Gentle, accessible to non-programmers | Steeper, rewards structured thinking |
| **Innovation speed** | Fast adoption of new paradigms | Deliberate, stability-focused evolution |

### Cultural Differences

The cultural gap between Python and Java communities is just as significant as the technical differences.

**Python's culture** is inclusive, academic and experimentation-friendly. The community values readability, simplicity and getting things done quickly. Conference talks are as likely to come from biologists and artists as from software engineers. "Move fast and try things" is the unofficial motto. There's a strong emphasis on making programming accessible to everyone, regardless of their background.

**Java's culture** is enterprise-oriented, architecturally disciplined and predictability-focused. The community values design patterns, comprehensive testing and systems that run reliably for years. Conference talks often feature architectural deep dives and production war stories. "Build it right the first time" is the guiding principle. There's a deep respect for backward compatibility and long-term maintainability.

Neither culture is better. They serve different needs and different contexts.

### Modern Systems Use Both

Here's what experienced architects know: the best systems often use both languages, each where it excels.

- **Java handles the transactional backbone.** Payment processing, order management, user authentication and core business logic, the parts where reliability, type safety and performance are non-negotiable.

- **Python handles the intelligence and automation layer.** Data analysis, machine learning inference, ETL pipelines, cloud automation and rapid prototyping, the parts where development speed and ecosystem richness matter most.

A typical modern enterprise might have Java microservices handling the core business operations, Python services running the recommendation engine and data pipelines and both languages sharing data through message queues and REST APIs.

### The Strategic Insight

If you want to think about it simply: **Python is the intelligence layer, Java is the infrastructure backbone.**

Python excels at answering the question "what should we do?", analyzing data, running models, discovering patterns and making recommendations. Java excels at answering "how do we do it reliably at scale?", processing transactions, managing state, enforcing business rules and serving millions of concurrent requests.

Organizations that understand this distinction and use each language where it's strongest end up with systems that are both smart and reliable. Trying to force either language into the other's natural domain usually leads to frustration.

---

## The Future Outlook

### Python's Road Ahead

Python's future is bright, but it's not without challenges. Here's what to watch for.

**Performance will keep improving.** The CPython core team has made performance a top priority. Each release gets measurably faster. The free-threaded mode (no GIL) will mature over the next few releases and if it succeeds, it removes one of the biggest arguments against Python for performance-sensitive applications.

**The packaging story will consolidate.** uv is rapidly becoming the modern standard for Python packaging. It's fast, it's comprehensive and it's backed by a well-funded team. Within a few years, the "which package manager should I use?" confusion will likely be a relic of the past.

**AI orchestration will deepen.** As AI becomes embedded in every software product, Python's role as the orchestration language for AI systems will only grow. Expect more frameworks, better tooling and deeper integration between Python and AI model serving infrastructure.

**Type safety will become standard practice.** The trend is clear. More codebases are adopting type hints, more tools support them and more teams require them. Python will increasingly offer a "gradual typing" experience where you can be as strict or as loose as your project demands.

**Education will continue to drive growth.** Every year, millions of new developers learn Python as their first language. This pipeline of new talent ensures that the community, the ecosystem and the job market will remain strong for decades to come.

### Java's Parallel Evolution

Java isn't standing still either.

**Virtual threads (Project Loom)** are transforming Java's concurrency model, making it easier to write highly concurrent applications. **GraalVM** enables ahead-of-time compilation, dramatically reducing startup times and memory usage. **Records, sealed classes and pattern matching** are making Java more expressive with each release.

Java's six-month release cycle means new features arrive steadily. The language is evolving faster than it has in years, while maintaining the backward compatibility that enterprises depend on.

### The Convergence

Interestingly, Python and Java are converging in some ways. Python is getting more type safety. Java is getting more expressiveness and less boilerplate. Both are improving their performance profiles. Both are investing in better developer experiences.

But their core identities remain distinct. Python will always prioritize developer happiness and accessibility. Java will always prioritize reliability and performance. And that's exactly how it should be. The software industry is big enough, and the problems diverse enough, to need both approaches.

---

## Conclusion: Key Takeaways

On this 35th birthday, here's what Python's journey teaches us.

**Design for humans first.** Guido's decision to optimize for readability over performance seemed counterintuitive in 1991. Three and a half decades later, it's the reason Python is the most popular language in the world. When you make something easy to learn and pleasant to use, people show up. And they stay.

**Ecosystems compound.** Python's greatest asset isn't any single feature, it's the millions of developers and hundreds of thousands of packages that form its ecosystem. This network effect is nearly impossible to replicate and it's what makes Python's position so durable.

**Adaptability beats specialization.** Python didn't try to be the best at any one thing. It tried to be good enough at everything while remaining true to its core values. That strategy worked spectacularly. Each new technology wave, web, data science, cloud, AI, found Python ready and willing to adapt.

**There's no one-size-fits-all language.** Python and Java have coexisted for three decades because they solve different problems differently. The most effective engineering organizations don't pick sides. They use the right tool for the right job.

**The best is yet to come.** With performance improvements accelerating, the GIL on its way out, packaging getting simpler and AI driving unprecedented demand, Python at 35 is positioned for its strongest decade yet.

Happy birthday, Python. Here's to the next 35.

---

## About the Author

**Wallace Espindola** is a Senior Software Engineer and Technical Lead with 25+ years of experience in Java, Python and software architecture. He builds backend systems, writes about technology and is passionate about sharing knowledge with the developer community.

**Connect with me:**
- [GitHub](https://github.com/wallaceespindola/)
- [LinkedIn](https://www.linkedin.com/in/wallaceespindola/)

---

*Tags: python, java, programming, softwaredevelopment, technology*
